// ÊµãËØïÂ•ó‰ª∂1ÔºöÂêàÁ∫¶ÂàùÂßãÂåñÈ™åËØÅ
const { expect } = require("chai");
const { ethers, deployments } = require("hardhat");
describe("MemeToken Contract", function () {
  // ËÆæÁΩÆÊµãËØïË∂ÖÊó∂Êó∂Èó¥ÔºàÂØπSepoliaÁΩëÁªúÂæàÈáçË¶ÅÔºâ
  this.timeout(300000); // 5ÂàÜÈíüË∂ÖÊó∂

  let memeToken;
  let deployer, taxBeneficiary;
  let network, isLocalNet;
  let signers;

  before(async function () {
    console.log("üöÄ [SETUP] Initializing test environment...");

    // Ê£ÄÊü•ÁΩëÁªúÁä∂ÊÄÅ
    network = await ethers.provider.getNetwork();
    // ‰øÆÂ§çÁΩëÁªúËØÜÂà´ÈÄªËæëÔºöÂü∫‰∫é chainId ÂíåÁΩëÁªúÂêçÁß∞
    isLocalNet = ["hardhat", "localhost"].includes(
      (network.name || "").toLowerCase()
    ) || network.chainId === 31337; // hardhat ÈªòËÆ§ chainId
    console.log(`üåê [NETWORK] ${network.name} (chainId: ${network.chainId}), local: ${isLocalNet}`);

    // Ëé∑ÂèñÁ≠æÂêçËÄÖË¥¶Êà∑
    signers = await ethers.getSigners();
    deployer = signers[0];
    taxBeneficiary = deployer;
    console.log(`üë• [ACCOUNTS] Got ${signers.length} signers, deployer: ${deployer.address}`);

    // Ëé∑ÂèñÊàñÈÉ®ÁΩ≤ÂêàÁ∫¶ - Ê†πÊçÆÁΩëÁªúÁ±ªÂûãÂÜ≥ÂÆöÊòØÂê¶ÈáçÊñ∞ÈÉ®ÁΩ≤
    if (isLocalNet) {
      // Êú¨Âú∞ÁΩëÁªúÔºö‰ΩøÁî® fixture ÈáçÊñ∞ÈÉ®ÁΩ≤Á°Æ‰øùÊµãËØïÁéØÂ¢ÉÂπ≤ÂáÄ
      console.log("   üè† Êú¨Âú∞ÁΩëÁªúÔºöÈáçÊñ∞ÈÉ®ÁΩ≤ÊâÄÊúâÂêàÁ∫¶");
      await deployments.fixture(["MemeToken"]);
    } else {
      // ËøúÁ®ãÁΩëÁªúÔºöÂ∞ùËØï‰ΩøÁî®Â∑≤ÈÉ®ÁΩ≤ÁöÑÂêàÁ∫¶ÔºåÂ¶ÇÊûú‰∏çÂ≠òÂú®ÂàôÈÉ®ÁΩ≤
      console.log("   üåê ËøúÁ®ãÁΩëÁªúÔºöÊü•ÊâæÂ∑≤ÈÉ®ÁΩ≤ÁöÑÂêàÁ∫¶");
      try {
        // Ê£ÄÊü•ÊòØÂê¶Â∑≤ÊúâÈÉ®ÁΩ≤ËÆ∞ÂΩï
        await deployments.get("MemeToken");
        console.log("   ‚úÖ ÊâæÂà∞Â∑≤ÈÉ®ÁΩ≤ÁöÑÂêàÁ∫¶");
      } catch (error) {
        console.log("   ‚ö†Ô∏è  Êú™ÊâæÂà∞Â∑≤ÈÉ®ÁΩ≤ÁöÑÂêàÁ∫¶ÔºåÂºÄÂßãÈÉ®ÁΩ≤...");
        await deployments.fixture(["MemeToken"]);
      }
    }

    // Ëé∑Âèñ MemeToken ÂêàÁ∫¶
    const deployment = await deployments.get("MemeToken");
    memeToken = await ethers.getContractAt("MemeToken", deployment.address, deployer);
    
    console.log(`üìÑ [CONTRACT] MemeToken deployed at: ${memeToken.address}`);
  });

  describe("ÊµãËØïÂ•ó‰ª∂1ÔºöÂêàÁ∫¶ÂàùÂßãÂåñÈ™åËØÅ", function () {
    it("should deploy successfully", function () {
      expect(memeToken.address).to.not.be.undefined;
    });

    it("should have correct name and symbol", async function () {
      const namePromise = memeToken.name();
      const timeoutPromise = new Promise((_, reject) =>
        setTimeout(
          () => reject(new Error("memeToken.name() timeout after 30 seconds")),
          30000
        )
      );

      try {
        const name = await Promise.race([namePromise, timeoutPromise]);
        const symbol = await memeToken.symbol();
        expect(name).to.equal("MemeToken");
        expect(symbol).to.equal("Meme");
      } catch (error) {
        console.log("‚ùå [TEST] Error in name/symbol test:", error.message);
        throw error;
      }
    });

    it("should assign total supply to deployer", async function () {
      const totalSupply = await memeToken.totalSupply();
      const deployerBalance = await memeToken.balanceOf(deployer.address);
      expect(deployerBalance).to.equal(totalSupply);
    });

    it("should have correct initial whitelist addresses", async function () {
      const isDeployerWhitelisted = await memeToken.isExcludedFromTax(deployer.address);
      const isContractWhitelisted = await memeToken.isExcludedFromTax(memeToken.address);
      const isTaxBeneficiaryWhitelisted = await memeToken.isExcludedFromTax(taxBeneficiary.address);
      
      expect(isDeployerWhitelisted).to.be.true;
      expect(isContractWhitelisted).to.be.true;
      expect(isTaxBeneficiaryWhitelisted).to.be.true;
    });

    it("should fail if non-owner calls mint", async function () {
      const addr1 = signers[1];

      if (isLocalNet) {
        await expect(
          memeToken.connect(addr1).mint(addr1.address, 100)
        ).to.be.revertedWithCustomError(
          memeToken,
          "OwnableUnauthorizedAccount"
        );
      } else {
        try {
          await memeToken.connect(addr1).mint(addr1.address, 100);
          throw new Error("Should have reverted");
        } catch (e) {
          if (!e) {
            throw new Error("Expected an exception but got none");
          }
        }
      }
    });

    it("should fail if non-owner calls setTaxRate", async function () {
      const addr1 = signers[1];

      if (isLocalNet) {
        await expect(
          memeToken.connect(addr1).setTaxRate(5)
        ).to.be.revertedWithCustomError(
          memeToken,
          "OwnableUnauthorizedAccount"
        );
      } else {
        try {
          await memeToken.connect(addr1).setTaxRate(5);
          throw new Error("Should have reverted");
        } catch (e) {
          if (!e) {
            throw new Error("Expected an exception but got none");
          }
        }
      }
    });

    it("should fail if non-owner calls addToWhitelist", async function () {
      const addr1 = signers[1];

      if (isLocalNet) {
        await expect(
          memeToken.connect(addr1).addToWhitelist(addr1.address)
        ).to.be.revertedWithCustomError(
          memeToken,
          "OwnableUnauthorizedAccount"
        );
      } else {
        try {
          await memeToken.connect(addr1).addToWhitelist(addr1.address);
          throw new Error("Should have reverted");
        } catch (e) {
          if (!e) {
            throw new Error("Expected an exception but got none");
          }
        }
      }
    });
  });

  describe("ÊµãËØïÂ•ó‰ª∂2ÔºöËΩ¨Ë¥¶Á®éÊî∂Êú∫Âà∂", function () {
    it("should transfer tokens without tax between whitelisted addresses", async function () {
      const addr1 = signers[1];
      
      // Á°Æ‰øùÈÉ®ÁΩ≤ËÄÖÊúâË∂≥Â§ü‰ΩôÈ¢ù
      const deployerInitialBalance = await memeToken.balanceOf(deployer.address);
      const requiredAmount = ethers.utils.parseUnits("100", 18);
      
      if (deployerInitialBalance.lt(requiredAmount)) {
        const mintTx = await memeToken.connect(deployer).mint(deployer.address, requiredAmount);
        if (!isLocalNet) {
          await mintTx.wait();
        }
      }

      // ÁôΩÂêçÂçïÂêëÊôÆÈÄöÂú∞ÂùÄËΩ¨Ë¥¶
      const transferTx = await memeToken
        .connect(deployer)
        .transfer(addr1.address, ethers.utils.parseUnits("50", 18));

      if (!isLocalNet) {
        await transferTx.wait();
      }

      const addr1Balance = await memeToken.balanceOf(addr1.address);
      expect(addr1Balance).to.equal(ethers.utils.parseUnits("50", 18));

      // ÊôÆÈÄöÂú∞ÂùÄÂêëÁôΩÂêçÂçïËΩ¨Ë¥¶
      const deployerBalanceBefore = await memeToken.balanceOf(deployer.address);
      const returnTransferTx = await memeToken
        .connect(addr1)
        .transfer(deployer.address, ethers.utils.parseUnits("20", 18));

      if (!isLocalNet) {
        await returnTransferTx.wait();
      }

      const addr1BalanceAfter = await memeToken.balanceOf(addr1.address);
      const deployerBalanceAfter = await memeToken.balanceOf(deployer.address);
      
      expect(addr1BalanceAfter).to.equal(ethers.utils.parseUnits("30", 18));
      expect(deployerBalanceAfter).to.equal(
        deployerBalanceBefore.add(ethers.utils.parseUnits("20", 18))
      );
    });

    it("should apply 5% tax on transfers between non-whitelisted addresses", async function () {
      const addr1 = signers[1];
      const addr2 = signers[2];
      
      const transferTx1 = await memeToken
        .connect(deployer)
        .transfer(addr1.address, ethers.utils.parseUnits("100", 18));

      if (!isLocalNet) {
        await transferTx1.wait();
      }

      const taxBeneficiaryBalanceBefore = await memeToken.balanceOf(taxBeneficiary.address);

      const transferTx2 = await memeToken
        .connect(addr1)
        .transfer(addr2.address, ethers.utils.parseUnits("100", 18));

      if (!isLocalNet) {
        await transferTx2.wait();
      }

      const addr2Balance = await memeToken.balanceOf(addr2.address);
      const taxBeneficiaryBalanceAfter = await memeToken.balanceOf(taxBeneficiary.address);
      
      expect(addr2Balance).to.equal(ethers.utils.parseUnits("95", 18)); // 100 - 5% = 95
      expect(taxBeneficiaryBalanceAfter).to.equal(
        taxBeneficiaryBalanceBefore.add(ethers.utils.parseUnits("5", 18))
      );
    });

    it("should emit TaxCollected event with correct parameters", async function () {
      const addr1 = signers[1];
      const addr2 = signers[2];
      
      const transferTx = await memeToken
        .connect(deployer)
        .transfer(addr1.address, ethers.utils.parseUnits("100", 18));

      if (!isLocalNet) {
        await transferTx.wait();
      }

      await expect(
        memeToken
          .connect(addr1)
          .transfer(addr2.address, ethers.utils.parseUnits("100", 18))
      )
        .to.emit(memeToken, "TaxCollected")
        .withArgs(
          addr1.address,
          taxBeneficiary.address,
          ethers.utils.parseUnits("5", 18)
        );
    });

    it("should apply 25% tax when tax rate is 25", async function () {
      const setTaxTx = await memeToken.connect(deployer).setTaxRate(25);
      if (!isLocalNet) {
        await setTaxTx.wait();
      }

      const addr1 = signers[1];
      const addr2 = signers[2];

      const mintTx = await memeToken
        .connect(deployer)
        .mint(deployer.address, ethers.utils.parseUnits("1000", 18));

      if (!isLocalNet) {
        await mintTx.wait();
      }

      const tx1 = await memeToken
        .connect(deployer)
        .transfer(addr1.address, ethers.utils.parseUnits("100", 18));

      if (!isLocalNet) {
        await tx1.wait();
      }

      const addr2BalanceBefore = await memeToken.balanceOf(addr2.address);
      const tx2 = await memeToken
        .connect(addr1)
        .transfer(addr2.address, ethers.utils.parseUnits("100", 18));

      if (!isLocalNet) {
        await tx2.wait();
      }

      const addr2BalanceAfter = await memeToken.balanceOf(addr2.address);
      expect(addr2BalanceAfter).to.equal(
        addr2BalanceBefore.add(ethers.utils.parseUnits("75", 18))
      ); // 100 - 25% = 75
    });

    it("should apply 0% tax when tax rate is 0", async function () {
      const setTaxTx = await memeToken.connect(deployer).setTaxRate(0);
      if (!isLocalNet) {
        await setTaxTx.wait();
      }

      const addr1 = signers[1];
      const addr2 = signers[2];

      const tx1 = await memeToken
        .connect(deployer)
        .transfer(addr1.address, ethers.utils.parseUnits("100", 18));

      if (!isLocalNet) {
        await tx1.wait();
      }

      const addr2BalanceBefore = await memeToken.balanceOf(addr2.address);
      const tx2 = await memeToken
        .connect(addr1)
        .transfer(addr2.address, ethers.utils.parseUnits("100", 18));

      if (!isLocalNet) {
        await tx2.wait();
      }

      const addr2BalanceAfter = await memeToken.balanceOf(addr2.address);
      expect(addr2BalanceAfter).to.equal(
        addr2BalanceBefore.add(ethers.utils.parseUnits("100", 18))
      ); // 100 - 0% = 100
    });
  });
  // ÊµãËØïÂ•ó‰ª∂3ÔºöÈò≤Êª•Áî®Êú∫Âà∂
  describe("ÊµãËØïÂ•ó‰ª∂3ÔºöÈò≤Êª•Áî®Êú∫Âà∂", function () {
    // 3.1 È™åËØÅÊúÄÂ§ß‰∫§ÊòìÈ¢ùÈôêÂà∂
    it("should enforce max transaction amount", async function () {
      console.log("net name is ",isLocalNet ? "local" : "remote");
      const addr1 = signers[1];
      
      // Ëé∑ÂèñÊúÄÂ§ß‰∫§ÊòìÈ¢ùÈôêÂà∂
      const maxTxAmount = await memeToken.maxTxAmount();
      console.log("üîç [TEST] Max Transaction Amount:", maxTxAmount.toString());
      
      // mint Ë∂≥Â§üÁöÑ‰ª£Â∏Å
      const mintTx = await memeToken
        .connect(deployer)
        .mint(deployer.address, maxTxAmount.add(1));
      
      if (!isLocalNet) {
        await mintTx.wait();
      }
      
      // ÊµãËØïË∂ÖËøáÊúÄÂ§ß‰∫§ÊòìÈ¢ùÂ∫îÂ§±Ë¥•
      const transferAmount = maxTxAmount.add(1);
      console.log("üîç [TEST] Attempting transfer of:", transferAmount.toString());
      console.log("üîç [TEST] Max allowed:", maxTxAmount.toString());
      
      // Ê£ÄÊü•ÈÉ®ÁΩ≤ËÄÖÁôΩÂêçÂçïÁä∂ÊÄÅÔºà‰ªÖÂú®ÈúÄË¶ÅÊó∂Ôºâ
      if (isLocalNet) {
        const isWhitelisted = await memeToken.isExcludedFromTax(deployer.address);
        console.log("üîç [TEST] Deployer is whitelisted:", isWhitelisted);
      }
      
      if (isLocalNet) {
        await expect(
          memeToken.connect(deployer).transfer(addr1.address, transferAmount)
        ).to.be.revertedWith("Exceeds max transaction amount");
      } else {
        try {
          const tx = await memeToken.connect(deployer).transfer(addr1.address, transferAmount);
          console.log("üîç [TEST] Transaction sent:", tx.hash);
          
          // Á≠âÂæÖ‰∫§ÊòìË¢´ÊåñÁüøÂπ∂Ê£ÄÊü•Áä∂ÊÄÅ
          const receipt = await tx.wait();
          console.log("üîç [TEST] Transaction receipt status:", receipt.status);
          
          if (receipt.status === 1) {
            console.log("‚ùå [TEST] Transaction unexpectedly succeeded");
            throw new Error("Should have reverted");
          } else {
            console.log("‚úÖ [TEST] Transaction correctly failed on remote network");
          }
        } catch (e) {
          console.log("üîç [TEST] Caught error:", e.message);
          if (e.message === "Should have reverted") {
            throw new Error("Expected transaction to fail but it succeeded");
          }
          // Â¶ÇÊûúÊòØÂêàÁ∫¶ revert ÊàñÂÖ∂‰ªñÈîôËØØÔºåËøôÊòØÊúüÊúõÁöÑË°å‰∏∫
          console.log("‚úÖ [TEST] Transaction correctly failed on remote network");
        }
      }
      
      // ÊµãËØïÁ≠â‰∫éÊúÄÂ§ß‰∫§ÊòìÈ¢ùÂ∫îÊàêÂäü
      const maxTransferTx = await memeToken.connect(deployer).transfer(addr1.address, maxTxAmount);
      if (!isLocalNet) {
        await maxTransferTx.wait();
      }
      
      // ‰øÆÊîπÊúÄÂ§ß‰∫§ÊòìÈ¢ù‰∏∫‰∏ÄÂçä
      const setMaxTx = await memeToken.connect(deployer).setMaxTxAmount(maxTxAmount.div(2));
      if (!isLocalNet) {
        await setMaxTx.wait();
      }
      
      const newMaxTxAmount = await memeToken.maxTxAmount();
      console.log("üîç [TEST] New Max Transaction Amount:", newMaxTxAmount.toString());
      
      // mint Êõ¥Â§ö‰ª£Â∏ÅÁî®‰∫éÊñ∞ÊµãËØï
      const mintTx2 = await memeToken
        .connect(deployer)
        .mint(deployer.address, newMaxTxAmount.add(1));
      if (!isLocalNet) {
        await mintTx2.wait();
      }
      
      // ÊµãËØïË∂ÖËøáÊñ∞ÊúÄÂ§ß‰∫§ÊòìÈ¢ùÂ∫îÂ§±Ë¥•
      const newTransferAmount = newMaxTxAmount.add(1);
      console.log("üîç [TEST] Attempting new transfer of:", newTransferAmount.toString());
      console.log("üîç [TEST] New max allowed:", newMaxTxAmount.toString());
      
      if (isLocalNet) {
        await expect(
          memeToken
            .connect(deployer)
            .transfer(addr1.address, newTransferAmount)
        ).to.be.revertedWith("Exceeds max transaction amount");
      } else {
        try {
          const tx = await memeToken
            .connect(deployer)
            .transfer(addr1.address, newTransferAmount);
          console.log("üîç [TEST] New transaction sent:", tx.hash);
          
          // Á≠âÂæÖ‰∫§ÊòìË¢´ÊåñÁüøÂπ∂Ê£ÄÊü•Áä∂ÊÄÅ
          const receipt = await tx.wait();
          console.log("üîç [TEST] New transaction receipt status:", receipt.status);
          
          if (receipt.status === 1) {
            console.log("‚ùå [TEST] New transfer unexpectedly succeeded");
            throw new Error("Should have reverted");
          } else {
            console.log("‚úÖ [TEST] New transfer correctly failed on remote network");
          }
        } catch (e) {
          console.log("üîç [TEST] Caught error on new transfer:", e.message);
          if (e.message === "Should have reverted") {
            throw new Error("Expected transaction to fail but it succeeded");
          }
          console.log("‚úÖ [TEST] New transfer correctly failed on remote network");
        }
      }
      
      console.log("‚úÖ [TEST] Max transaction amount test completed");
    });

    it("should enforce max daily transaction count", async function () {
      const addr1 = signers[1];
      const addr2 = signers[2];

      // ÈÉ®ÁΩ≤ËÄÖËΩ¨Ë¥¶Áªôaddr1
      const initialTx = await memeToken
        .connect(deployer)
        .transfer(addr1.address, ethers.utils.parseUnits("100", 18));

      if (!isLocalNet) {
        await initialTx.wait();
      }

      // ËØªÂèñÊúÄÂ§ßÊó•‰∫§ÊòìÊ¨°Êï∞
      const maxDailyTxCount = await memeToken.maxDailyTxCount();
      console.log("üìä [TEST] Max Daily Transaction Count:", maxDailyTxCount.toString());

      // Ê†πÊçÆÁΩëÁªúË∞ÉÊï¥ÊµãËØïÂæ™ÁéØÊ¨°Êï∞
      const testIterations = isLocalNet ? maxDailyTxCount : Math.min(maxDailyTxCount, 2);

      // ‰øÆÊîπÊúÄÂ§ßÊó•‰∫§ÊòìÊ¨°Êï∞‰∏∫ÊµãËØïÊ¨°Êï∞
      const setMaxDailyTx = await memeToken.connect(deployer).setMaxDailyTxCount(testIterations);
      // ËøûÁª≠ËΩ¨Ë¥¶ËææÂà∞ÈôêÂà∂
      for (let i = 0; i < testIterations; i++) {
        const tx = await memeToken
          .connect(addr1)
          .transfer(addr2.address, ethers.utils.parseUnits("1", 18));

        if (!isLocalNet) {
          await tx.wait();
        }
      }

      // Ë∂ÖËøáÈôêÂà∂ÁöÑËΩ¨Ë¥¶Â∫îÂ§±Ë¥•
      if (isLocalNet) {
        await expect(
          memeToken
            .connect(addr1)
            .transfer(addr2.address, ethers.utils.parseUnits("1", 18))
        ).to.be.revertedWith("Exceeds daily transaction count");
      } else {
        try {
          await memeToken
            .connect(addr1)
            .transfer(addr2.address, ethers.utils.parseUnits("1", 18));
          throw new Error("Should have reverted");
        } catch (e) {
          if (!e) {
            throw new Error("Expected an exception but got none");
          }
        }
      }

      // ‰ªÖÂú®Êú¨Âú∞ÁΩëÁªúÊµãËØïÊó∂Èó¥ÂâçËøõ
      if (network.chainId !== 31337) {
        console.log("‚ö†Ô∏è [TEST] Skipping time manipulation test on non-local network");
        return;
      }

      // Ê®°ÊãüÊó∂Èó¥ÂâçËøõ24Â∞èÊó∂
      await ethers.provider.send("evm_increaseTime", [24 * 60 * 60]);
      await ethers.provider.send("evm_mine", []);

      // Êó∂Èó¥ÈáçÁΩÆÂêéÂÜçÊ¨°ËΩ¨Ë¥¶Â∫îÊàêÂäü
      await expect(
        memeToken
          .connect(addr1)
          .transfer(addr2.address, ethers.utils.parseUnits("1", 18))
      ).to.not.be.reverted;
    });
    it("should fail on transfers to zero address, contract itself, or insufficient balance", async function () {
      const addr1 = signers[1];

      // ÈÉ®ÁΩ≤ËÄÖËΩ¨Ë¥¶Áªôaddr1
      const tx = await memeToken
        .connect(deployer)
        .transfer(addr1.address, ethers.utils.parseUnits("10", 18));

      if (!isLocalNet) {
        await tx.wait();
      }

      // Âêë0Âú∞ÂùÄËΩ¨Ë¥¶Â∫îÂ§±Ë¥•
      if (isLocalNet) {
        await expect(
          memeToken
            .connect(addr1)
            .transfer(
              ethers.constants.AddressZero,
              ethers.utils.parseUnits("1", 18)
            )
        ).to.be.revertedWith("Invalid recipient");
      } else {
        try {
          await memeToken
            .connect(addr1)
            .transfer(
              ethers.constants.AddressZero,
              ethers.utils.parseUnits("1", 18)
            );
          throw new Error("Should have reverted");
        } catch (e) {
          if (!e) {
            throw new Error("Expected an exception but got none");
          }
        }
      }

      // ÂêëÂêàÁ∫¶Ëá™Ë∫´ËΩ¨Ë¥¶Â∫îÂ§±Ë¥•
      if (isLocalNet) {
        await expect(
          memeToken
            .connect(addr1)
            .transfer(memeToken.address, ethers.utils.parseUnits("1", 18))
        ).to.be.revertedWith("Cannot transfer to contract");
      } else {
        try {
          await memeToken
            .connect(addr1)
            .transfer(memeToken.address, ethers.utils.parseUnits("1", 18));
          throw new Error("Should have reverted");
        } catch (e) {
          if (!e) {
            throw new Error("Expected an exception but got none");
          }
        }
      }

      // ‰ΩôÈ¢ù‰∏çË∂≥Êó∂ËΩ¨Ë¥¶Â∫îÂ§±Ë¥•
      const addr1Balance = await memeToken.balanceOf(addr1.address);
      if (isLocalNet) {
        await expect(
          memeToken
            .connect(addr1)
            .transfer(deployer.address, addr1Balance.add(1))
        ).to.be.revertedWith("Insufficient balance");
      } else {
        try {
          await memeToken
            .connect(addr1)
            .transfer(deployer.address, addr1Balance.add(1));
          throw new Error("Should have reverted");
        } catch (e) {
          if (!e) {
            throw new Error("Expected an exception but got none");
          }
        }
      }
    });
  });
  describe("Management Functions", function () {
    it("should manage whitelist correctly", async function () {
      const addr1 = signers[1];
      const addr2 = signers[2];

      // È™åËØÅÂàùÂßãÁä∂ÊÄÅ
      let isAddr1Whitelisted = await memeToken.isExcludedFromTax(addr1.address);
      expect(isAddr1Whitelisted).to.be.false;

      // Ê∑ªÂä†addr1Âà∞ÁôΩÂêçÂçï
      const addWhitelistTx = await memeToken.connect(deployer).addToWhitelist(addr1.address);
      if (!isLocalNet) {
        await addWhitelistTx.wait();
      }

      isAddr1Whitelisted = await memeToken.isExcludedFromTax(addr1.address);
      expect(isAddr1Whitelisted).to.be.true;

      // ÊµãËØïÁôΩÂêçÂçïËΩ¨Ë¥¶ÂÖçÁ®é
      const tx1 = await memeToken
        .connect(deployer)
        .transfer(addr1.address, ethers.utils.parseUnits("50", 18));

      if (!isLocalNet) {
        await tx1.wait();
      }

      const addr1Balance = await memeToken.balanceOf(addr1.address);
      expect(addr1Balance).to.equal(ethers.utils.parseUnits("50", 18));

      const tx2 = await memeToken
        .connect(addr1)
        .transfer(addr2.address, ethers.utils.parseUnits("20", 18));

      if (!isLocalNet) {
        await tx2.wait();
      }

      const addr2Balance = await memeToken.balanceOf(addr2.address);
      expect(addr2Balance).to.equal(ethers.utils.parseUnits("20", 18)); // ‰∏çÊâ£Á®é

      // ÁßªÈô§ÁôΩÂêçÂçï
      const removeWhitelistTx = await memeToken
        .connect(deployer)
        .removeFromWhitelist(addr1.address);

      if (!isLocalNet) {
        await removeWhitelistTx.wait();
      }

      isAddr1Whitelisted = await memeToken.isExcludedFromTax(addr1.address);
      expect(isAddr1Whitelisted).to.be.false;

      // ÊµãËØïÁßªÈô§ÂêéÊÅ¢Â§çÊâ£Á®é
      const addr2BalanceBefore = await memeToken.balanceOf(addr2.address);
      const taxRate = await memeToken.getTaxRate();

      const tx3 = await memeToken
        .connect(addr1)
        .transfer(addr2.address, ethers.utils.parseUnits("20", 18));

      if (!isLocalNet) {
        await tx3.wait();
      }

      const addr2BalanceAfter = await memeToken.balanceOf(addr2.address);
      const expectedReceived = addr2BalanceBefore.add(
        ethers.utils
          .parseUnits("20", 18)
          .mul(100 - taxRate)
          .div(100)
      );
      expect(addr2BalanceAfter).to.equal(expectedReceived);

      // ÈáçÂ§çÊ∑ªÂä†ÁôΩÂêçÂçïÊµãËØï
      const addWhitelist1Tx = await memeToken.connect(deployer).addToWhitelist(addr1.address);
      if (!isLocalNet) {
        await addWhitelist1Tx.wait();
      }

      const addWhitelist2Tx = await memeToken.connect(deployer).addToWhitelist(addr1.address);
      if (!isLocalNet) {
        await addWhitelist2Tx.wait();
      }

      isAddr1Whitelisted = await memeToken.isExcludedFromTax(addr1.address);
      expect(isAddr1Whitelisted).to.be.true;
    });

    it("should update tax beneficiary correctly", async function () {
      const addr1 = signers[1];
      const addr2 = signers[2];
      const addr3 = signers[3];

      // ‰øÆÊîπÂèóÁõä‰∫∫Âú∞ÂùÄ‰∏∫addr1
      const setBeneficiaryTx = await memeToken.connect(deployer).setTaxBeneficiaries(addr1.address);
      if (!isLocalNet) {
        await setBeneficiaryTx.wait();
      }

      // ÂáÜÂ§áÊµãËØïËΩ¨Ë¥¶
      const tx1 = await memeToken
        .connect(deployer)
        .transfer(addr2.address, ethers.utils.parseUnits("100", 18));

      if (!isLocalNet) {
        await tx1.wait();
      }

      const taxBeneficiaryBalanceBefore = await memeToken.balanceOf(addr1.address);

      const tx2 = await memeToken
        .connect(addr2)
        .transfer(addr3.address, ethers.utils.parseUnits("100", 18));

      if (!isLocalNet) {
        await tx2.wait();
      }

      // È™åËØÅÁ®éË¥πÊµÅÂêëÊñ∞ÂèóÁõä‰∫∫
      const taxBeneficiaryBalanceAfter = await memeToken.balanceOf(addr1.address);
      const taxRate = await memeToken.getTaxRate();
      const expectedTax = ethers.utils
        .parseUnits("100", 18)
        .mul(taxRate)
        .div(100);
      expect(taxBeneficiaryBalanceAfter).to.equal(
        taxBeneficiaryBalanceBefore.add(expectedTax)
      );

      // È™åËØÅÊñ∞ÂèóÁõä‰∫∫Ëá™Âä®Âä†ÂÖ•ÁôΩÂêçÂçï
      const isAddr1Whitelisted = await memeToken.isExcludedFromTax(addr1.address);
      expect(isAddr1Whitelisted).to.be.true;
    });
  });
});
